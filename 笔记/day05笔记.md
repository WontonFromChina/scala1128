# 一. 昨日内容复习

1. 函数和方法区别

2. 部分应用函数

3. 面向对象

   - 属性自带`getter`和`setter`
   - `BeanProperty` 生产标准的`setter和getter`

4. 继承

   - 关键字 `extendes`
   - 方法的继承
     - 两同两小一大
   - 属性的继承
     - `var`只能覆写抽象的`var`
     - `val`可以覆写`val`和没有参数的`def`

5. 抽象类

   - 相比普通类多了 抽象属性和抽象方法
   - 抽象属性
     - 只有属性名和类型, 没有对属性进行初始化
   - 抽象方法
     - 只有签名, 没有实现

6. 包

   - 包的声明

     - 和`java`一样的

     - 一个文件可以有多个声明语句`package ...`

     - 包语句(一般不适用)

       ```scala
       package a{
           
       }
       ```

       

   - 包的导入

     - 和`java`一样, 在文件的最顶部
     - 可以在任何位置导入
     - 通配符导入  `_`
     - 给导入的类起别名

   - 包对象(包对象)

7. 访问控制

   - 默认(`public`)

   - `protected`

     - 调用父类的方法

       ```scala
       super.foo()  // 正确
       new Father().foo() // 错误
       ```

   - `private`

     ```scala
     private[a] ..
     //a包内可以访问到
     ```

# 二. 单例对象

```scala
object 对象名{
    // 也可以写代码
    def main(args: Array[String]){
        // 入口
    }
}
```



# 三. 伴生类和伴生对象

```scala
object User{
    // 也可以写代码
    def main(args: Array[String]){
        // 入口
    }
}
class User(val age: Int){
    
}
```



1. `class`的名字和`object`的名字相同, 就是伴生类和伴生对象
2. 他们可以互相访问对方的私有成员
3. 伴生类和 伴生对象必须在同一个`.scala`文件中
4. 将来编译成字节码之后, 站在`java`的角度, 伴生对象中的都是为成为静态成员, 伴生类中的成员都会成为非静态成员.

## `apply`

函数的特点是可以调用! 

其实, 在`scala`中, ***任何对象***也可以像函数一样去调用执行.

```scala
//函数调用:
函数名(参数 )  // 函数名.apply(参数)
// 对象调用
对象名(参数)   // 等价于去调用对象的 apply方法
```

注意:  

1. 其实函数也可以通过apply进行调用.  (方法不行), 如果是方法, 先把方法转成函数在使用.
2. **伴生对象**的`apply`, 通常情况是返回***伴生类的对象***, 然后在外面创建对象的时候, 可以省略`new`
3. 普通类中的`apply`, 一般根据具体的业务逻辑来实现.
4. `apply` 也可以重载

# 四.`trait`

特质(`trait`)

`java`中接口不够面向面向对象, 就有`trait`

接口:   实现

特质:  混入

特质的本质: 字节码之后, 还是接口

特质是支持多混入!!!

## 都可以有哪些成员

抽象类能有的成员, 那么特质都可有

1. 属性
2. 方法
3. 抽象属性
4. 抽象方法
5. 构造器(主/辅)

> `java`接口:
>
> 1.  1.8之前: 是抽象方法和常量的集合
> 2. 从1.8开始, 默认方法

## `trait`和抽象类的区别

`trait`可以多混入, 抽象类只能单继承



















